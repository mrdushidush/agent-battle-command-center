/**
 * ZIP Service — Generates downloadable ZIP bundles for mission files
 *
 * Produces a DEFLATE-compressed ZIP containing all generated code files
 * plus a README.md with mission metadata, subtask manifest, and results.
 */

import JSZip from 'jszip';

// ─── Types ───────────────────────────────────────────────────────────────────

export interface ZipMissionMetadata {
  missionId: string;
  prompt: string;
  language: string;
  reviewScore: number | null;
  totalCost: number;
  totalTimeMs: number;
  subtaskCount: number;
  completedCount: number;
  failedCount: number;
  plan: Array<{
    title: string;
    file_name: string;
    complexity: number;
  }> | null;
  taskStatuses: Record<string, string>; // file_name → 'completed' | 'failed' etc.
}

// ─── ZIP Generation ──────────────────────────────────────────────────────────

/**
 * Generate a ZIP buffer containing all mission files + README.
 */
export async function generateMissionZip(
  files: Record<string, string>,
  metadata: ZipMissionMetadata,
): Promise<Buffer> {
  const zip = new JSZip();

  // Add all code files (flat, strip any path prefixes)
  for (const [filename, content] of Object.entries(files)) {
    const name = filename.split('/').pop() || filename;
    zip.file(name, content);
  }

  // Generate and add README.md
  const readme = generateReadme(files, metadata);
  zip.file('README.md', readme);

  // Compress with DEFLATE level 6
  const buffer = await zip.generateAsync({
    type: 'nodebuffer',
    compression: 'DEFLATE',
    compressionOptions: { level: 6 },
  });

  return buffer;
}

// ─── README Template ─────────────────────────────────────────────────────────

function generateReadme(
  files: Record<string, string>,
  meta: ZipMissionMetadata,
): string {
  const lines: string[] = [];

  lines.push('# Mission Output');
  lines.push('');
  lines.push(`> ${meta.prompt}`);
  lines.push('');

  // Summary table
  lines.push('## Summary');
  lines.push('');
  lines.push(`| Field | Value |`);
  lines.push(`|-------|-------|`);
  lines.push(`| Language | ${meta.language} |`);
  if (meta.reviewScore != null) {
    lines.push(`| Review Score | ${meta.reviewScore}/10 |`);
  }
  const passRate = meta.subtaskCount > 0
    ? `${meta.completedCount}/${meta.subtaskCount} (${Math.round((meta.completedCount / meta.subtaskCount) * 100)}%)`
    : 'N/A';
  lines.push(`| Pass Rate | ${passRate} |`);
  lines.push(`| Cost | $${meta.totalCost.toFixed(4)} |`);
  lines.push(`| Time | ${(meta.totalTimeMs / 1000).toFixed(1)}s |`);
  lines.push('');

  // File manifest
  if (meta.plan && meta.plan.length > 0) {
    lines.push('## Files');
    lines.push('');
    lines.push('| File | Subtask | Complexity | Status |');
    lines.push('|------|---------|------------|--------|');
    for (const subtask of meta.plan) {
      const fileName = subtask.file_name?.split('/').pop() || subtask.file_name;
      const status = meta.taskStatuses[fileName] || 'unknown';
      const statusIcon = status === 'completed' ? 'PASS' : status === 'failed' ? 'FAIL' : status.toUpperCase();
      lines.push(`| ${fileName} | ${subtask.title} | C${subtask.complexity} | ${statusIcon} |`);
    }
  } else {
    // No plan — just list files
    lines.push('## Files');
    lines.push('');
    for (const filename of Object.keys(files)) {
      const name = filename.split('/').pop() || filename;
      lines.push(`- \`${name}\``);
    }
  }

  lines.push('');
  lines.push('---');
  lines.push(`Generated by ABCC | Mission \`${meta.missionId}\` | ${new Date().toISOString()}`);
  lines.push('');

  return lines.join('\n');
}
